<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WeApRous Chat - Discord Style</title>
    <link rel="stylesheet" href="../static/css/chat.css">
    <style> 
        
/* * { margin: 0; padding: 0; box-sizing: border-box; } */
body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
    background: #1a1d21; 
    color: #e4e6eb; 
    height: 100vh; 
    overflow: hidden; 
}

.app { 
    display: grid; 
    grid-template-columns: 240px 1fr 220px; 
    height: 100vh; 
}

/* Left Sidebar - Channels */
.channels-sidebar { 
    background: #1e2124; 
    display: flex; 
    flex-direction: column; 
    border-right: 1px solid #2a2d31;
}
.server-name { 
    padding: 16px; 
    font-weight: 600; 
    color: #fff; 
    background: #5865f2;
    font-size: 15px; 
    box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.channels-list { 
    flex: 1; 
    overflow-y: auto; 
    padding: 12px 8px; 
}
.channels-list::-webkit-scrollbar { width: 4px; }
.channels-list::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

.channel-category { 
    color: #96989d; 
    font-size: 11px; 
    font-weight: 600; 
    text-transform: uppercase; 
    padding: 16px 8px 6px 8px; 
    letter-spacing: 0.5px; 
}
.channel-item { 
    padding: 7px 10px; 
    margin: 1px 0; 
    border-radius: 6px; 
    cursor: pointer; 
    display: flex; 
    align-items: center; 
    transition: background 0.15s;
}
.channel-item:hover { 
    background: rgba(88,101,242,0.08); 
}
.channel-item.active { 
    background: rgba(88,101,242,0.15);
    color: #fff; 
}
.channel-icon { 
    margin-right: 8px; 
    opacity: 0.6; 
    font-size: 16px; 
}
.channel-item.active .channel-icon { opacity: 1; }
.channel-name { font-size: 14px; }
.channel-badge { 
    margin-left: auto; 
    background: #ed4245;
    color: white; 
    font-size: 10px; 
    padding: 2px 6px; 
    border-radius: 8px; 
    font-weight: 600; 
}

/* Center - Chat Area *//* ƒê·∫£m b·∫£o container cha c√≥ chi·ªÅu cao c·ªë ƒë·ªãnh */
.chat-area { 
    background: #23262a;
    display: flex; 
    flex-direction: column; 
    height: 100vh; /* Quan tr·ªçng */
    min-height: 0; /* Quan tr·ªçng cho flexbox */
}

.chat-header { 
    height: 52px; 
    padding: 0 20px; 
    border-bottom: 1px solid #2a2d31;
    display: flex; 
    align-items: center; 
    background: #1e2124;
    flex-shrink: 0; /* Kh√¥ng b·ªã co l·∫°i */
}

.chat-input-area { 
    padding: 16px 20px; 
    background: #1e2124;
    flex-shrink: 0; /* Kh√¥ng b·ªã co l·∫°i */
}
.chat-header-title { 
    font-size: 16px; 
    font-weight: 600; 
    color: #fff; 
}
.chat-header-desc { 
    margin-left: 8px;

    color: #96989d; 
    font-size: 13px; 
}
.chat-messages { 
    flex: 1; 
    padding: 16px 20px; 
    overflow-y: auto; 
    /* Th√™m c√°c thu·ªôc t√≠nh sau */
    max-height: calc(100vh - 120px); /* Gi·ªõi h·∫°n chi·ªÅu cao t·ªëi ƒëa */
    min-height: 200px; /* Chi·ªÅu cao t·ªëi thi·ªÉu */
    scroll-behavior: smooth; /* Cu·ªôn m∆∞·ª£t */
}

/* T√πy ch·ªânh thanh scrollbar cho ƒë·∫πp h∆°n */
.chat-messages::-webkit-scrollbar { 
    width: 8px; 
}
.chat-messages::-webkit-scrollbar-track { 
    background: rgba(255,255,255,0.05); 
    border-radius: 4px;
}
.chat-messages::-webkit-scrollbar-thumb { 
    background: rgba(255,255,255,0.2); 
    border-radius: 4px; 
}
.chat-messages::-webkit-scrollbar-thumb:hover { 
    background: rgba(255,255,255,0.3); 
}s
.message-group { 
    margin-bottom: 16px; 
    padding: 8px 12px;
    border-radius: 6px;
}
.message-group:hover { background: rgba(255,255,255,0.02); }
.message-header { display: flex; align-items: baseline; margin-bottom: 4px; }
.message-author { 
    font-weight: 600; 
    color: #ffffff; 
    font-size: 15px; 
    cursor: pointer; 
}
.message-author:hover { text-decoration: underline; }
.message-time { 
    margin-left: 8px; 
    font-size: 11px; 
    color: #6d6f78; 
}
.message-content { 
    color: #dcddde; 
    line-height: 1.5; 
    word-wrap: break-word; 
    font-size: 14px;
}
.message-dm { 
    background: rgba(88,101,242,0.08);
    padding: 10px 12px; 
    border-radius: 6px; 
    border-left: 3px solid #5865f2; 
}
.system-message { 
    color: #96989d; 
    font-size: 13px; 
    padding: 12px 16px; 
    background: rgba(88,101,242,0.06);
    border-radius: 6px; 
    margin-bottom: 12px; 
    border: 1px solid rgba(88,101,242,0.15);
    line-height: 1.6;
}
.system-message strong { color: #fff; }

.chat-input-area { 
    padding: 16px 20px; 
    background: #1e2124;
}
.input-wrapper { 
    background: #2a2d31;
    border-radius: 8px; 
    padding: 10px 14px; 
    display: flex; 
    align-items: center; 
}
.input-wrapper:focus-within { 
    box-shadow: 0 0 0 2px rgba(88,101,242,0.3);
}
.input-wrapper textarea { 
    background: transparent; 
    border: none; 
    color: #dcddde; 
    width: 100%; 
    resize: none; 
    outline: none; 
    font-family: inherit; 
    font-size: 14px; 
    min-height: 40px; 
    line-height: 1.4;
}
.input-wrapper textarea::placeholder { color: #6d6f78; }
.send-buttons { display: flex; gap: 8px; margin-top: 10px; }
.send-buttons button { 
    padding: 8px 16px; 
    border: none; 
    border-radius: 6px; 
    font-weight: 600; 
    cursor: pointer; 
    font-size: 13px; 
    transition: all 0.15s;
}
.btn-send { 
    background: #5865f2;
    color: white; 
}
.btn-send:hover {
    background: #4752c4;
}
.btn-broadcast { 
    background: #faa61a;
    color: white; 
}
.btn-broadcast:hover { 
    background: #ee8c03;
}

/* Right Sidebar - Members/DMs */
.members-sidebar { 
    background: #1e2124;
    padding: 16px 12px; 
    overflow-y: auto; 
    border-left: 1px solid #2a2d31;
}
.members-sidebar::-webkit-scrollbar { width: 4px; }
.members-sidebar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

.members-title { 
    color: #96989d; 
    font-size: 11px; 
    font-weight: 600; 
    text-transform: uppercase; 
    margin-bottom: 10px; 
    letter-spacing: 0.5px; 
}
.member-item { 
    padding: 6px 8px; 
    margin: 1px 0; 
    border-radius: 6px; 
    cursor: pointer; 
    display: flex; 
    align-items: center; 
    transition: background 0.15s;
}
.member-item:hover { 
    background: rgba(88,101,242,0.08); 
}
.member-item.active { 
    background: rgba(88,101,242,0.15);
}
.member-status { 
    width: 8px; 
    height: 8px; 
    border-radius: 50%; 
    background: #3ba55d;
    margin-right: 8px; 
}
.member-name { font-size: 13px; }

/* Registration Popup */
.registration-popup { 
    position: fixed; 
    top: 0; 
    left: 0; 
    right: 0; 
    bottom: 0; 
    background: rgba(0,0,0,0.85);
    display: flex; 
    align-items: center; 
    justify-content: center; 
    z-index: 1000; 
}
.registration-box { 
    background: #23262a;
    padding: 32px; 
    border-radius: 8px; 
    width: 440px; 
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
    border: 1px solid #2a2d31;
}
.registration-box h2 { 
    color: white; 
    margin-bottom: 24px; 
    text-align: center; 
    font-size: 22px;
    font-weight: 600;
}
.form-group { margin-bottom: 18px; }
.form-group label { 
    display: block; 
    color: #b9bbbe; 
    font-size: 12px; 
    font-weight: 600; 
    margin-bottom: 8px; 
    text-transform: uppercase; 
}
.form-group input { 
    width: 100%; 
    padding: 10px 12px; 
    background: #1e2124;
    border: 1px solid #2a2d31;
    border-radius: 6px; 
    color: #dcddde; 
    font-size: 14px; 
}
.form-group input:focus { 
    outline: none; 
    border-color: #5865f2;
}
.register-btn {
    width: 100%; 
    padding: 12px; 
    background: #5865f2;
    color: white; 
    border: none; 
    border-radius: 6px; 
    font-weight: 600; 
    font-size: 15px; 
    cursor: pointer; 
    margin-top: 8px;
}
.register-btn:hover { 
    background: #4752c4;
}

.notification { 
    position: fixed; 
    bottom: 20px; 
    right: 20px; 
    background: #3ba55d;
    color: white; 
    padding: 12px 16px; 
    border-radius: 6px; 
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 2000; 
    font-weight: 500;
    font-size: 14px;
}

.context-indicator { 
    margin-left: auto; 
    padding: 4px 12px; 
    background: #5865f2;
    border-radius: 12px; 
    font-size: 11px; 
    font-weight: 600; 
}
.context-dm { background: #7289da; }

#inputHint {
    margin-top: 8px; 
    font-size: 12px; 
    color: #6d6f78;
}
#p2pConnect, #p2pBroadcast, #p2pClose {
    padding: 10px 18px;
    margin: 6px;
    border: none;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    font-weight: 600;
    transition: 0.2s ease;
}

/* M√†u ri√™ng cho t·ª´ng n√∫t */
#p2pConnect {
    background: #4caf50;
    color: white;
}

#p2pBroadcast {
    background: #2196f3;
    color: white;
}

#p2pClose {
    background: #f44336;
    color: white;
}

/* Hover */
#p2pConnect:hover {
    background: #43a047;
}

#p2pBroadcast:hover {
    background: #1e88e5;
}

#p2pClose:hover {
    background: #e53935;
}


    </style>
</head>
<body>
    <!-- Registration Popup -->
    <div class="registration-popup" id="registrationPopup">
        <div class="registration-box">
            <h2> Join the Chat</h2>
            <div class="form-group">
                <label>Username</label>
                <input type="text" id="peerName" placeholder="Enter your username" value="" required>
            </div>
            <div class="form-group">
                <label>IP Address</label>
                <input type="text" id="peerIP" placeholder="127.0.0.1" value="127.0.0.1">
            </div>
            <div class="form-group">
                <label>Port</label>
                <input type="text" id="peerPort" placeholder="5001" value="5001" required>
            </div>
            <button class="register-btn" onclick="registerPeer()">Join Server</button>
        </div>
    </div>
<div id="p2pModal" style="display: none;">
    <div>
        <h3>Backend Unavailable - Connect P2P</h3>
        <div>Select peers to connect:</div>
        
        <!-- Peer List -->
        <div id="p2pPeerList">
            <!-- Peer items will be added here -->
        </div>
        
        <!-- Buttons -->
        <div>
            <button id="p2pConnect">Connect All Peers</button>
            <button id="p2pBroadcast">Broadcast</button>
            <button id="p2pClose">Close</button>
        </div>
    </div>
</div>
    <!-- Main App -->
    <div class="app" style="display: none;" id="mainApp">
        <!-- Left Sidebar - Channels -->
        <div class="channels-sidebar">
            <div class="server-name">üí¨ WeApRous Chat</div>
            <div class="channels-list">
                <div class="channel-category">Text Channels</div>
                <div class="channel-item active" onclick="switchToChannel('general')">
                    <span class="channel-icon">#</span>
                    <span class="channel-name">general</span>
                    <span class="channel-badge" id="badge-general" style="display:none;">0</span>
                </div>
                <div class="channel-item" onclick="switchToChannel('random')">
                    <span class="channel-icon">#</span>
                    <span class="channel-name">random</span>
                    <span class="channel-badge" id="badge-random" style="display:none;">0</span>
                </div>
                <div class="channel-item" onclick="switchToChannel('tech')">
                    <span class="channel-icon">#</span>
                    <span class="channel-name">tech-talk</span>
                    <span class="channel-badge" id="badge-tech" style="display:none;">0</span>
                </div>
            </div>
        </div>

        <!-- Center - Chat Area -->
        <div class="chat-area">
            <div class="chat-header">
                <span class="channel-icon" style="font-size: 20px; margin-right: 8px;">#</span>
                <span class="chat-header-title" id="channelTitle">general</span>
                <span class="chat-header-desc" id="channelDesc">| General chat</span>
                <span class="context-indicator" id="contextIndicator">Channel</span>
            </div>
            
            <div class="chat-messages" id="messages">
                <div class="system-message">
                    <strong> Welcome to WeApRous Chat!</strong><br>
                    This is a Discord-style real-time chat application.<br>
                    ‚Ä¢ <strong>Channels</strong>: Public rooms - everyone in the channel sees all messages<br>
                    ‚Ä¢ <strong>Direct Messages</strong>: Private 1-on-1 chat - only you and recipient see<br>
                    ‚Ä¢ Messages update automatically every 1.5 seconds!
                </div>
            </div>
            
            <div class="chat-input-area">
                <div class="input-wrapper">
                    <textarea id="messageInput" placeholder="Message #general" rows="1"></textarea>
                </div>
                <div class="send-buttons">
                    <button class="btn-send" onclick="sendMessage()" id="sendBtn"> Send in Channel</button>
                    <button class="btn-send" onclick="sendDM()" id="dmBtn" style="display:none;">üí¨ Send DM</button>
                </div>
                <div style="margin-top: 8px; font-size: 12px; color: #72767d;" id="inputHint">
                    Sending to: <span id="sendTarget">#general (everyone in channel)</span>
                </div>
            </div>
        </div>

        <!-- Right Sidebar - Members -->
         <div class="members-sidebar">
    <!-- Th√™m n√∫t Connect P2P ·ªü ƒë√¢y -->
    <div class="p2p-connect-section">
        <button class="p2p-connect-btn" onclick="showP2PModal()">
            üîó Connect P2P
        </button>
        <div class="p2p-status" id="p2pStatusText">
            Backend Mode
        </div>
    </div>
        <div class="members-sidebar">
            <div class="members-title">Online ‚Äî <span id="memberCount">0</span></div>
            <div id="membersList"></div>
            
            <div class="members-title" style="margin-top: 24px;">Direct Messages</div>
            <div id="dmList">
                <div style="color: #72767d; font-size: 13px; padding: 8px;">No DMs yet</div>
            </div>
        </div>
    </div>

  <script>
    let myPeerInfo = null;
    let activePeers = [];
    let currentChannel = 'general';
    let currentMode = 'channel'; // 'channel' or 'dm'
    let currentDMPeer = null;
    let pollingInterval = null;
    let messageCount = { general: 0, random: 0, tech: 0 };
    let dmMessageCount = {}; // {peer_name: unread_count}
    let dmConversations = {}; // {peer_name: [messages]}
    
    // üî• TRUE P2P - Fallback when backend is DOWN
    let backendAvailable = true;
    let p2pChannel = null;
    let backendCheckInterval = null;
    let p2pConnections = [];
    let p2pPollingInterval = null;

    // ==================== P2P CORE FUNCTIONS ====================

    // Kh·ªüi t·∫°o P2P system
    function initP2P() {
        console.log('üîÑ Initializing P2P system...');
        
        // 1. BroadcastChannel cho real-time communication
        if ('BroadcastChannel' in window) {
            p2pChannel = new BroadcastChannel('weaprous_p2p');
            p2pChannel.onmessage = (event) => {
                handleP2PMessage(event.data);
            };
            console.log('[P2P] BroadcastChannel initialized');
        }
        
        // 2. LocalStorage polling l√†m fallback
        startP2PPolling();
        
        console.log('‚úÖ P2P system ready');
    }

    // X·ª≠ l√Ω tin nh·∫Øn P2P
    function handleP2PMessage(msg) {
        console.log('[P2P] Received message:', msg);
        
        // Don't process own messages
        if (msg.from === myPeerInfo.name) return;
        
        if (msg.type === 'direct' && msg.to === myPeerInfo.name) {
            // Direct message
            if (!dmConversations[msg.from]) {
                dmConversations[msg.from] = [];
            }
            dmConversations[msg.from].push(msg);
            
            if (currentMode === 'dm' && currentDMPeer === msg.from) {
                displayMessage(msg);
            } else {
                dmMessageCount[msg.from] = (dmMessageCount[msg.from] || 0) + 1;
                updateDMBadge(msg.from);
            }
            showNotification(`üí¨ P2P DM from ${msg.from}`);
        } else if (msg.type === 'broadcast' && msg.channel === currentChannel && currentMode === 'channel') {
            // Broadcast message
            displayMessage(msg);
            if (msg.from !== myPeerInfo.name) {
                showNotification(`üì¢ P2P: ${msg.from} in #${msg.channel}`);
            }
        } else if (msg.type === 'peer_announce') {
            // Peer announcement
            updateP2PPeer(msg.peer);
        }
    }

    // Polling cho LocalStorage messages
    function startP2PPolling() {
        if (p2pPollingInterval) clearInterval(p2pPollingInterval);
        
        p2pPollingInterval = setInterval(() => {
            checkLocalStorageMessages();
        }, 1000);
        
        console.log('[P2P] LocalStorage polling started');
    }

    function checkLocalStorageMessages() {
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            
            if (key && key.startsWith('p2p_msg_')) {
                try {
                    const msgData = localStorage.getItem(key);
                    const message = JSON.parse(msgData);
                    
                    // Ch·ªâ x·ª≠ l√Ω tin nh·∫Øn kh√¥ng ph·∫£i c·ªßa m√¨nh
                    if (message.from !== myPeerInfo.name) {
                        console.log('üì® Received P2P message from LocalStorage:', message);
                        handleP2PMessage(message);
                        localStorage.removeItem(key);
                    }
                } catch (e) {
                    console.error('Error processing P2P message:', e);
                    localStorage.removeItem(key);
                }
            }
        }
    }

    // G·ª≠i tin nh·∫Øn P2P
    function sendP2PMessage(message, type = 'broadcast', target = null) {
        const msg = {
            type: type,
            from: myPeerInfo.name,
            message: message,
            channel: currentChannel,
            timestamp: new Date().toISOString()
        };
        
        if (type === 'direct' && target) {
            msg.to = target;
        }
        
        console.log(`üì® Sending P2P ${type} message:`, msg);
        
        // ∆Øu ti√™n BroadcastChannel
        if (p2pChannel) {
            p2pChannel.postMessage(msg);
        } else {
            // Fallback: LocalStorage
            const messageId = 'p2p_msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            localStorage.setItem(messageId, JSON.stringify(msg));
            
            // Auto cleanup sau 2 gi√¢y
            setTimeout(() => {
                localStorage.removeItem(messageId);
            }, 2000);
        }
        p2pConnections.forEach(peer => {
        if (peer.name !== myPeerInfo.name) { // Kh√¥ng g·ª≠i cho ch√≠nh m√¨nh
            console.log(`üì§ Sending to peer: ${peer.name} (${peer.ip}:${peer.port})`);
            // ·ªû ƒë√¢y b·∫°n c·∫ßn c√≥ c√°ch g·ª≠i ƒë·∫øn peer - v√≠ d·ª• qua HTTP request
            // Nh∆∞ng hi·ªán t·∫°i ch∆∞a c√≥ endpoint nh·∫≠n tin nh·∫Øn P2P
        }
    });
        return true;
    }

    // ==================== PEER MANAGEMENT ====================

    // Load v√† hi·ªÉn th·ªã peers
    async function loadAndDisplayPeers() {
    try {
        console.log('üîÑ Loading peers for modal...');
        
        const response = await fetch('http://localhost:9000/get-list', {
            signal: AbortSignal.timeout(3000)
        });
        
        if (response.ok) {
            const data = await response.json();
            const peers = data.peers || [];
            console.log('üìã Loaded peers from backend:', peers);
            displayPeersInModal(peers);
        } else {
            console.log('‚ùå Backend response not OK, using current activePeers');
            // ‚úÖ D√πng activePeers hi·ªán t·∫°i (c√≥ th·ªÉ ch·ª©a P2P peers)
            displayPeersInModal(activePeers);
        }
        
    } catch (error) {
        console.error('‚ùå Backend failed, using current activePeers:', error);
        // ‚úÖ D√πng activePeers hi·ªán t·∫°i (c√≥ th·ªÉ ch·ª©a P2P peers)
        displayPeersInModal(activePeers);
    }
}

    // Hi·ªÉn th·ªã peers trong modal
    function displayPeersInModal(peers) {
    const peerListDiv = document.getElementById('p2pPeerList');
    if (!peerListDiv) return;
    
    peerListDiv.innerHTML = '';
    
    // Filter out self and duplicates
    const uniquePeers = peers.filter((peer, index, self) => 
        peer.name !== myPeerInfo?.name && 
        self.findIndex(p => p.name === peer.name) === index
    );
    
    if (uniquePeers.length === 0) {
        peerListDiv.innerHTML = '<div style="padding: 10px; text-align: center; color: #666;">No peers available</div>';
        return;
    }
    
    uniquePeers.forEach(peer => {
        const peerDiv = document.createElement('div');
        peerDiv.style.marginBottom = '8px';
        peerDiv.style.padding = '10px';
        peerDiv.style.border = '1px solid #40444b';
        peerDiv.style.borderRadius = '6px';
        peerDiv.style.background = '#2f3136';
        
        // Real-time connection check
        const isConnected = p2pConnections.some(p => p.name === peer.name);
        const isConnecting = false; // C√≥ th·ªÉ th√™m tr·∫°ng th√°i "connecting"
        
        let buttonText = 'Connect';
        let buttonColor = '#5865f2';
        
        if (isConnecting) {
            buttonText = 'üîÑ Connecting';
            buttonColor = '#faa61a';
        } else if (isConnected) {
            buttonText = '‚úÖ Connected';
            buttonColor = '#3ba55d';
        }
        
        peerDiv.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div style="flex: 1;">
                    <strong style="color: white;">${peer.name}</strong><br>
                    <small style="color: #72767d;">${peer.ip}:${peer.port}</small>
                </div>
                <button onclick="handlePeerConnection('${peer.name}', '${peer.ip}', ${peer.port})" 
                        style="padding: 6px 12px; background: ${buttonColor}; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;"
                        ${isConnected ? 'disabled' : ''}>
                    ${buttonText}
                </button>
            </div>
        `;
        
        peerListDiv.appendChild(peerDiv);
    });
    
    updateP2PStatus();
}

// H√†m x·ª≠ l√Ω connection v·ªõi logic r√µ r√†ng h∆°n
function handlePeerConnection(name, ip, port) {
    const existingConnection = p2pConnections.find(p => p.name === name);
    
    if (existingConnection) {
        showNotification(`‚ö†Ô∏è Already connected to ${name}`);
        return;
    }
    
    // Th√™m tr·∫°ng th√°i "connecting"
    showNotification(`üîó Connecting to ${name}...`);
    
    p2pConnections.push({ name, ip, port });
    
    // Refresh UI ƒë·ªÉ hi·ªÉn th·ªã tr·∫°ng th√°i m·ªõi
    loadAndDisplayPeers();
    
    // Announce ourselves
    sendP2PMessage('peer_announce', 'peer_announce');
}

    // K·∫øt n·ªëi ƒë·∫øn peer
    function connectToPeer(name, ip, port) {
        console.log(`üîó Connecting to ${name} at ${ip}:${port}`);
        
        const existingConnection = p2pConnections.find(p => p.name === name);
        if (!existingConnection) {
            p2pConnections.push({ name, ip, port });
            console.log(`‚úÖ ${name} added to P2P connections`);
            showNotification(`‚úÖ ${name} available for P2P messaging`);
            
            // Announce ourselves to this peer
            sendP2PMessage('peer_announce', 'peer_announce');
        } else {
            console.log(`‚ö†Ô∏è Already connected to ${name}`);
            showNotification(`‚ö†Ô∏è Already connected to ${name}`);
        }
        
        // Refresh UI
        loadAndDisplayPeers();
    }

    // Update P2P status
    function updateP2PStatus() {
        const statusElement = document.getElementById('p2pStatus') || document.createElement('div');
        statusElement.id = 'p2pStatus';
        statusElement.innerHTML = `
            <div style="margin-top: 15px; padding: 10px; background: #2a2d31; border-radius: 6px; border-left: 4px solid #5865f2;">
                <strong style="color: white;">P2P Status</strong>
                <div style="font-size: 12px; color: #b9bbbe; margin-top: 5px;">
                    Connected to: ${p2pConnections.length} peers<br>
                    Mode: ${backendAvailable ? 'Backend' : 'P2P Only'}
                </div>
            </div>
        `;
        
        const peerListDiv = document.getElementById('p2pPeerList');
        const existingStatus = document.getElementById('p2pStatus');
        if (existingStatus) {
            existingStatus.remove();
        }
        peerListDiv.appendChild(statusElement);
    }

    // ==================== MODAL FUNCTIONS ====================

    // Hi·ªÉn th·ªã modal P2P
    function showP2PModal() {
        const modal = document.getElementById('p2pModal');
        if (!modal) return;
        
        loadAndDisplayPeers();
        modal.style.display = 'block';
        console.log('üîÑ P2P Modal opened');
    }

    // ·∫®n modal P2P
    function hideP2PModal() {
        const modal = document.getElementById('p2pModal');
        if (modal) {
            modal.style.display = 'none';
        }
    }

    // ==================== BACKEND HEALTH CHECK ====================

    function startBackendHealthCheck() {
        console.log('üîÑ Starting backend health check...');
        
        backendCheckInterval = setInterval(async () => {
            try {
                const response = await fetch('http://localhost:9000/get-list', {
                    signal: AbortSignal.timeout(2000)
                });
                
                if (!backendAvailable && response.ok) {
                    backendAvailable = true;
                    const modal = document.getElementById('p2pModal');
                    if (modal) {
                        modal.style.display = 'none';
                    }
                    console.log('‚úÖ Backend is back online');
                }
            } catch (e) {
                if (backendAvailable) {
                    backendAvailable = false;
                    console.log('‚ùå Backend is down - P2P mode activated');
                    
                    // Announce ourselves via P2P
                    sendP2PMessage('peer_announce', 'peer_announce');
                }
            }
        },1500);
    }

    // ==================== MESSAGE FUNCTIONS ====================

    async function sendMessage() {
        const message = document.getElementById('messageInput').value.trim();
        if (!message) return;
        
        try {
            // Try backend first
            if (backendAvailable) {
                const response = await fetch('http://localhost:9000/broadcast-peer', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                    body: `sender_name=${encodeURIComponent(myPeerInfo.name)}&message=${encodeURIComponent(message)}&channel=${encodeURIComponent(currentChannel)}`,
                    signal: AbortSignal.timeout(3000)
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    document.getElementById('messageInput').value = '';
                    return;
                }
            }
        } catch (e) {
            console.log('[Send] Backend failed, using P2P fallback');
            backendAvailable = false;
            showP2PModal();
        }
        
        // Fallback to P2P
        if (!backendAvailable) {
            if (p2pConnections.length > 0) {
                sendP2PMessage(message, 'broadcast');
                
                // Hi·ªÉn th·ªã tin nh·∫Øn c·ªßa m√¨nh
                displayMessage({
                    from: myPeerInfo.name,
                    message: message,
                    channel: currentChannel,
                    timestamp: new Date().toISOString(),
                    type: 'broadcast'
                });
                
                document.getElementById('messageInput').value = '';
                showNotification(`üì¢ P2P: Sent to ${p2pConnections.length} peers`);
            } else {
                showP2PModal();
                showNotification('‚ö†Ô∏è No P2P connections! Connect to peers first.');
            }
        }
    }

    async function sendDM() {
        if (!currentDMPeer) return;
        
        const message = document.getElementById('messageInput').value.trim();
        if (!message) return;
        
        try {
            // Try backend first
            if (backendAvailable) {
                const response = await fetch('http://localhost:9000/send-peer', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                    body: `sender_name=${encodeURIComponent(myPeerInfo.name)}&target_name=${encodeURIComponent(currentDMPeer)}&message=${encodeURIComponent(message)}&channel=dm`,
                    signal: AbortSignal.timeout(3000)
                });
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    document.getElementById('messageInput').value = '';
                    return;
                }
            }
        } catch (e) {
            console.log('[Send] Backend failed, using P2P fallback');
            backendAvailable = false;
        }
        
        // Fallback to P2P
        if (!backendAvailable) {
            if (p2pConnections.find(p => p.name === currentDMPeer)) {
                sendP2PMessage(message, 'direct', currentDMPeer);
                
                // Store in local conversation
                if (!dmConversations[currentDMPeer]) {
                    dmConversations[currentDMPeer] = [];
                }
                
                const msg = {
                    type: 'direct',
                    from: myPeerInfo.name,
                    to: currentDMPeer,
                    message: message,
                    timestamp: new Date().toISOString()
                };
                
                dmConversations[currentDMPeer].push(msg);
                displayMessage(msg);
                document.getElementById('messageInput').value = '';
                console.log('[P2P] Sent DM');
            } else {
                showNotification(`‚ùå ${currentDMPeer} is not connected via P2P`);
            }
        }
    }

    // ==================== EVENT LISTENERS ====================

    document.addEventListener('DOMContentLoaded', function() {
        // P2P Modal buttons
        document.getElementById('p2pConnect').addEventListener('click', function() {
            console.log('üîó Connect All Peers clicked');
            // Connect to all available peers
            const peerItems = document.querySelectorAll('#p2pPeerList div');
            peerItems.forEach(peerItem => {
                const name = peerItem.querySelector('strong').textContent;
                const ip = '127.0.0.1'; // Default IP
                const port = 5001; // Default port
                connectToPeer(name, ip, port);
            });
        });
        
        document.getElementById('p2pBroadcast').addEventListener('click', function() {
            const message = prompt('Enter broadcast message for P2P:');
            if (message && p2pConnections.length > 0) {
                sendP2PMessage(message, 'broadcast');
                showNotification(`üì¢ P2P: "${message}" sent to ${p2pConnections.length} peers`);
            } else if (!message) {
                alert('Please enter a message!');
            } else {
                alert('No peers connected! Connect to peers first.');
            }
        });
        
        document.getElementById('p2pClose').addEventListener('click', hideP2PModal);
        
        // Close modal when clicking outside
        window.addEventListener('click', function(event) {
            const modal = document.getElementById('p2pModal');
            if (event.target === modal) {
                hideP2PModal();
            }
        });
    });

    // ==================== EXISTING FUNCTIONS (gi·ªØ nguy√™n) ====================

    function updateP2PPeer(peer) {
        const exists = activePeers.find(p => p.name === peer.name);
        if (!exists) {
            activePeers.push(peer);
            refreshPeerListUI();
            console.log('[P2P] Added peer:', peer.name);
        }
    }
    
    function refreshPeerListUI() {
        document.getElementById('memberCount').textContent = activePeers.length;
        
        const membersList = document.getElementById('membersList');
        membersList.innerHTML = '';
        
        activePeers.forEach(peer => {
            const div = document.createElement('div');
            div.className = 'member-item';
            const isYou = myPeerInfo && peer.name === myPeerInfo.name;
            
            if (isYou) {
                div.style.background = '#5865f2';
                div.style.color = 'white';
                div.style.cursor = 'default';
            } else {
                div.onclick = () => switchToDM(peer.name);
                div.style.cursor = 'pointer';
            }
            
            div.innerHTML = `
                <span class="member-status"></span>
                <span class="member-name">${peer.name}${isYou ? ' (You)' : ''}</span>
            `;
            membersList.appendChild(div);
        });
        
        const dmList = document.getElementById('dmList');
        dmList.innerHTML = '';
        
        const otherPeers = activePeers.filter(p => !myPeerInfo || p.name !== myPeerInfo.name);
        
        if (otherPeers.length === 0) {
            dmList.innerHTML = '<div style="color: #72767d; font-size: 13px; padding: 8px;">No peers available for DM</div>';
        } else {
            otherPeers.forEach(peer => {
                const div = document.createElement('div');
                div.className = 'member-item';
                div.onclick = () => switchToDM(peer.name);
                div.style.cursor = 'pointer';
                
                const unreadCount = dmMessageCount[peer.name] || 0;
                const badgeHTML = unreadCount > 0 
                    ? `<span class="channel-badge" id="dm-badge-${peer.name}">${unreadCount}</span>` 
                    : '';
                
                div.innerHTML = `
                    <span class="member-status"></span>
                    <span class="member-name">${peer.name}</span>
                    ${badgeHTML}
                `;
                dmList.appendChild(div);
            });
        }
    }

    async function registerPeer() {
        const name = document.getElementById('peerName').value.trim();
        const ip = document.getElementById('peerIP').value.trim();
        const port = document.getElementById('peerPort').value.trim();
        
        if (!name || !ip || !port) {
            alert('‚ö†Ô∏è Please fill in all fields');
            return;
        }
        
        try {
            const response = await fetch('http://localhost:9000/submit-info', {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: `name=${encodeURIComponent(name)}&ip=${encodeURIComponent(ip)}&port=${encodeURIComponent(port)}`
            });
            
            const result = await response.json();
            
            if (result.status === 'success') {
                myPeerInfo = {name, ip, port};
                document.getElementById('registrationPopup').style.display = 'none';
                document.getElementById('mainApp').style.display = 'grid';
                
                showNotification(`Welcome, ${name}!`);
                
                // Initialize P2P and backend health check
                initP2P();
                startBackendHealthCheck();
                
                refreshPeerList();
                loadChannelHistory('general');
                startMessagePolling();
            } else {
                alert('‚ùå Registration failed: ' + result.message);
            }
        } catch (e) {
            alert('‚ùå Error: ' + e.message);
        }
    }

    function startMessagePolling() {
        if (pollingInterval) clearInterval(pollingInterval);
        
        pollingInterval = setInterval(async () => {
            if (myPeerInfo && myPeerInfo.name) {
                await fetchNewMessages();
            }
        }, 1500);
        
        console.log('[Polling] Started (1.5s interval)');
    }

    async function fetchNewMessages() {
        try {
            const response = await fetch('http://localhost:9000/get-messages', {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: `peer_name=${encodeURIComponent(myPeerInfo.name)}`
            });
            
            const result = await response.json();
            
            if (result.status === 'success' && result.messages && result.messages.length > 0) {
                result.messages.forEach(msg => {
                    const msgChannel = msg.channel || 'general';
                    
                    if (msg.type === 'direct') {
                        const otherPerson = msg.from === myPeerInfo.name ? msg.to : msg.from;
                        if (!dmConversations[otherPerson]) {
                            dmConversations[otherPerson] = [];
                        }
                        dmConversations[otherPerson].push(msg);
                        
                        if (currentMode === 'dm' && currentDMPeer === otherPerson) {
                            displayMessage(msg);
                        } else {
                            if (msg.from !== myPeerInfo.name) {
                                dmMessageCount[otherPerson] = (dmMessageCount[otherPerson] || 0) + 1;
                                updateDMBadge(otherPerson);
                            }
                        }
                        
                        if (msg.from !== myPeerInfo.name) {
                            showNotification(`üí¨ DM from ${msg.from}`);
                        }
                    } else if (msg.type === 'broadcast' || msg.type === 'channel') {
                        if (currentMode === 'channel' && currentChannel === msgChannel) {
                            displayMessage(msg);
                            if (msg.from !== myPeerInfo.name) {
                                showNotification(`üì¢ ${msg.from} in #${msgChannel}`);
                            }
                        } else {
                            updateChannelBadge(msgChannel);
                        }
                    }
                });
            }
        } catch (e) {
            console.error('[Polling] Error:', e);
        }
    }

    function displayMessage(msg) {
        const messagesDiv = document.getElementById('messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message-group';
        
        const isSelf = msg.from === myPeerInfo.name;
        const isDM = msg.type === 'direct';
        
        messageDiv.innerHTML = `
            <div class="message-header">
                <span class="message-author" style="color: ${isSelf ? '#faa61a' : '#5865f2'}">${msg.from}</span>
                <span class="message-time">${getTime()}</span>
            </div>
            <div class="message-content ${isDM ? 'message-dm' : ''}">${escapeHtml(msg.message)}</div>
        `;
        
        messagesDiv.appendChild(messageDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function switchToChannel(channelName) {
        currentMode = 'channel';
        currentChannel = channelName;
        currentDMPeer = null;
        
        document.querySelectorAll('.channel-item').forEach(el => el.classList.remove('active'));
        event.target.closest('.channel-item').classList.add('active');
        document.querySelectorAll('.member-item').forEach(el => el.classList.remove('active'));
        
        const titles = {general: 'general', random: 'random', tech: 'tech-talk'};
        const descs = {general: '| General chat', random: '| Off-topic fun', tech: '| Programming & tech'};
        
        document.getElementById('channelTitle').textContent = titles[channelName];
        document.getElementById('channelDesc').textContent = descs[channelName];
        document.getElementById('messageInput').placeholder = `Message #${titles[channelName]}`;
        document.getElementById('sendTarget').textContent = `#${titles[channelName]} (everyone in channel)`;
        document.getElementById('contextIndicator').textContent = 'Channel';
        document.getElementById('contextIndicator').className = 'context-indicator';
        document.getElementById('sendBtn').style.display = 'block';
        document.getElementById('dmBtn').style.display = 'none';
        
        const badge = document.getElementById('badge-' + channelName);
        if (badge) {
            badge.style.display = 'none';
            messageCount[channelName] = 0;
        }
        
        document.getElementById('messages').innerHTML = '';
        addSystemMessage(`Switched to #${titles[channelName]}`);
        loadChannelHistory(channelName);
    }

    async function loadChannelHistory(channelName) {
        try {
            const response = await fetch('http://localhost:9000/get-channel-history', {
                method: 'POST',
                headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                body: `channel=${encodeURIComponent(channelName)}`
            });
            
            const result = await response.json();
            
            if (result.status === 'success' && result.messages) {
                result.messages.forEach(msg => displayMessage(msg));
            }
        } catch (e) {
            console.error('[Channel History] Error:', e);
        }
    }

    function switchToDM(peerName) {
        currentMode = 'dm';
        currentDMPeer = peerName;
        
        dmMessageCount[peerName] = 0;
        updateDMBadge(peerName);
        
        document.querySelectorAll('.channel-item').forEach(el => el.classList.remove('active'));
        document.querySelectorAll('.member-item').forEach(el => el.classList.remove('active'));
        event.target.closest('.member-item').classList.add('active');
        
        document.getElementById('channelTitle').textContent = peerName;
        document.getElementById('channelDesc').textContent = '| Direct Message';
        document.getElementById('messageInput').placeholder = `Message @${peerName}`;
        document.getElementById('sendTarget').textContent = `@${peerName} (private)`;
        document.getElementById('contextIndicator').textContent = 'DM';
        document.getElementById('contextIndicator').className = 'context-indicator context-dm';
        document.getElementById('sendBtn').style.display = 'none';
        document.getElementById('dmBtn').style.display = 'block';
        
        document.getElementById('messages').innerHTML = '';
        if (dmConversations[peerName]) {
            dmConversations[peerName].forEach(msg => displayMessage(msg));
        }
        addSystemMessage(`Private conversation with @${peerName}`);
    }

   async function refreshPeerList() {
    try {
        // 1. Fetch data t·ª´ backend
        const response = await fetch('http://localhost:9000/get-list');
        const data = await response.json();
        
        // 2. C·∫≠p nh·∫≠t data
        activePeers = data.peers || [];
        
        // 3. G·ªçi h√†m refresh UI
        refreshPeerListUI();
        
        console.log(`‚úÖ Peerlist updated: ${activePeers.length} peers`);
        
    } catch (e) {
        console.error('Error fetching peers:', e);
    }
}

    function addSystemMessage(content) {
        const messagesDiv = document.getElementById('messages');
        const div = document.createElement('div');
        div.className = 'system-message';
        div.innerHTML = content;
        messagesDiv.appendChild(div);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function showNotification(message) {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 3000);
    }

    function updateChannelBadge(channelName) {
        const badge = document.getElementById('badge-' + channelName);
        if (badge && currentChannel !== channelName) {
            messageCount[channelName]++;
            badge.textContent = messageCount[channelName];
            badge.style.display = 'inline-block';
        }
    }

    function updateDMBadge(peerName) {
        const badge = document.getElementById('dm-badge-' + peerName);
        if (badge) {
            const count = dmMessageCount[peerName] || 0;
            badge.textContent = count;
            badge.style.display = count > 0 ? 'inline-block' : 'none';
        } else {
            refreshPeerList();
        }
    }

    function getTime() {
        const now = new Date();
        return now.getHours().toString().padStart(2, '0') + ':' + 
               now.getMinutes().toString().padStart(2, '0');
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    setInterval(refreshPeerList, 3000);

    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            if (currentMode === 'channel') {
                sendMessage();
            } else {
                sendDM();
            }
        }
    });

    window.addEventListener('beforeunload', function(e) {
        if (myPeerInfo && myPeerInfo.name) {
            navigator.sendBeacon('http://localhost:9000/unregister', 
                new URLSearchParams({name: myPeerInfo.name}));
        }
    });
</script>
</body>
</html>
